package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;
// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	List<String> textos = new ArrayList<String>();
	int global_address = 0;
	int s_size = 1;	

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales

// Constantes literales
terminal Token LITERAL_ENTERO;
terminal Token LITERAL_CADENA;

// Identificadores
terminal Token ID;

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token DO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PROGRAM;
terminal Token RECORD;
terminal Token THEN;
terminal Token TO;
terminal Token TRUE;
terminal Token TYPE;
terminal Token VAR;
terminal Token WRITE;
terminal Token WRITELN;

// Delimitadores
terminal Token PARENT_ABRIR;
terminal Token PARENT_CERRAR;
terminal Token COMA;
terminal Token PUNTO_Y_COMA;
terminal Token DOS_PUNTOS;
terminal Token IGUAL;

// Operadores
terminal Token MENOS;
terminal Token MAYOR_QUE;
terminal Token DOS_PUNTOS_IGUAL;
terminal Token PUNTO;
terminal Token CIRCUNFLEJO;
terminal Token ARROBA;

// Declaracion de no terminales
// no modificar los propuestos
non terminal program;
non terminal Axiom axiom;
non terminal Declaraciones declaraciones;
non terminal Bloque bloque;
non terminal SecuenciaSentencias secuencia_sentencias;
non terminal Sentencia sentencia;
non terminal DeclaracionTipos decl_tipos;
non terminal DeclaracionVariables decl_variables;
non terminal DeclaracionSubprogramas decl_subprogramas;
non terminal SecuenciaConstantes secuencia_constantes;
non terminal Constante constante;
non terminal LiteralEnteroOLogico literal_entero_o_logico;
non terminal LiteralLogico literal_logico;
non terminal SecuenciaTipos secuencia_tipos;
non terminal Tipo tipo;
non terminal SecuenciaVariables secuencia_variables;
non terminal Variabl variabl;
non terminal SecuenciaIDs secuencia_IDs;
non terminal TipoDatos tipo_datos;
non terminal TipoPrimitivo tipo_primitivo;
non terminal SecuenciaCamposRegistro secuencia_campos_registro;
non terminal CampoRegistro campo_registro;
non terminal DeclaracionProcedimiento decl_procedimiento;
non terminal DeclaracionFuncion decl_funcion;
non terminal DeclaracionParametros decl_parametros;
non terminal SecuenciaParametros secuencia_parametros;
non terminal Parametro parametro;
non terminal Expresion exp;
non terminal SecuenciaParametrosLlamada secuencia_parametros_llamada;
non terminal SentenciaAsignacion sentencia_asignacion;
non terminal SentenciaAsignacionIzq sentencia_asignacion_izq;
non terminal LlamadaSubprograma llamada_subprograma;
non terminal SentenciaIF sentencia_if;
non terminal SentenciasThenElseFor sentencias_then_else_for;
non terminal SentenciaFor sentencia_for;
non terminal SentenciaWrite sentencia_write;
non terminal ParametroWrite parametro_write;
non terminal ParteElse parte_else;

// Declaracion de relaciones de asociatividad
// Declaracion de relaciones de precedencia

precedence left 		ELSE;
precedence nonassoc		MAYOR_QUE, IGUAL;
precedence left			MENOS, OR;
precedence left			PUNTO, PARENT_ABRIR, PARENT_CERRAR;

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir mas acciones semanticas
  		// Para la entrega de febrero pueden comentarse las sentencias siguientes:
  		List intermediateCode = ax.getIntermediateCode ();
		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);
  		
  		// CODIGO INTERMEDIO -- SALIDA POR PANTALLA
		syntaxErrorManager.syntaxInfo("-----------------");
		syntaxErrorManager.syntaxInfo("CODIGO INTERMEDIO");
		syntaxErrorManager.syntaxInfo("-----------------");
		Iterator it = intermediateCode.iterator();
		while ( it.hasNext() ) {
			syntaxErrorManager.syntaxInfo(it.next().toString());
		}
   :};


axiom ::= PROGRAM:prg ID:id 
		{:
           scopeManager.openScope(id.getLexema());
           ScopeIF scope = scopeManager.getCurrentScope();
           
           //Insertar todos los tipos simples en la TT
		   TypeTableIF tablaTipos = scope.getTypeTable();
		   	
		   TypeSimple tipoBooleano = new TypeBoolean(scope);
		   tablaTipos.addType(tipoBooleano);
		   
		   TypeSimple tipoEntero = new TypeInteger(scope);
           tablaTipos.addType(tipoEntero);
           	
           TypePointer tipoPuntero = new TypePointer(scope,"POINTER");
           tablaTipos.addType(tipoPuntero);	           
           
		:} PUNTO_Y_COMA declaraciones:dec bloque:bloq PUNTO
			{:
				ScopeIF scope = scopeManager.getCurrentScope();				          				
				
                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                                                
                cb.addQuadruple("INICIAR",null);
                cb.addQuadruples(dec.getIntermediateCode());
                cb.addQuadruples(bloq.getIntermediateCode());
                cb.addQuadruple("HALT", null);
                   
                                
                //Asignar posiciones relativas de memoria a variables no globales
                List<ScopeIF> scopes = scopeManager.getAllScopes();
                for (ScopeIF scop: scopes){
                	int v_offset=0;
                	List<SymbolIF> symbols = scop.getSymbolTable().getSymbols();
                	List<TemporalIF> temporals = scop.getTemporalTable().getTemporals();
                	for (SymbolIF s: symbols){
                		if(s instanceof SymbolVariable){                			
                			SymbolVariable sv = (SymbolVariable)scop.getSymbolTable().getSymbol(s.getName());
                			if (scop.getLevel()!=0) sv.setAddress(v_offset++);	             				
                		}
                		
                		if(s instanceof SymbolConstant){                			
                			SymbolConstant sc = (SymbolConstant)scop.getSymbolTable().getSymbol(s.getName());
                			if (scop.getLevel()!=0){
                				sc.setAddress(v_offset++);  
                			}
                			            				
                		}  
                	}
                	for (SymbolIF s: symbols){
                		if(s instanceof SymbolParameter){                			
                			SymbolParameter sp = (SymbolParameter)scop.getSymbolTable().getSymbol(s.getName());
                			if (scop.getLevel()!=0) sp.setAddress(v_offset++);	             				
                		}
                	}
                	
                	for (TemporalIF t: temporals){
                		t.setAddress(v_offset++);
                	}                	
                }
                
                for (String texto: textos){
                	Value val = new Value(textos.indexOf(texto));
                	cb.addQuadruple("TEXT", texto, val);
                }
                
                cb.addQuadruple("SALTO", null);
                
                List intermediateCode = cb.create();                                 
                
                Axioma axi = new Axioma();
                axi.setIntermediateCode(intermediateCode);
                RESULT = axi;               
			:}; 
		
// Las declaraciones incluyen, de forma opcional pero siempre en este orden:
// constantes, tipos, variables globales y subprogramas
declaraciones ::= CONST secuencia_constantes:sc decl_tipos:dt 
						{: 
							Declaraciones ds = new Declaraciones();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(sc.getIntermediateCode());
							cb.addQuadruples(dt.getIntermediateCode());
							ds.setIntermediateCode(cb.create());							
							RESULT = ds; 
						:} 
			| decl_tipos:dt 
						{: 
							Declaraciones ds = new Declaraciones();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(dt.getIntermediateCode());
							ds.setIntermediateCode(cb.create());							
							RESULT = ds; 
						:};

decl_tipos ::= TYPE secuencia_tipos:sc decl_variables:dv 
						{: 
							DeclaracionTipos dt = new DeclaracionTipos();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(sc.getIntermediateCode());
							cb.addQuadruples(dv.getIntermediateCode());
							dt.setIntermediateCode(cb.create());							
							RESULT = dt; 
						:}
		| decl_variables:dv 
						{: 
							DeclaracionTipos dt = new DeclaracionTipos();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(dv.getIntermediateCode());
							dt.setIntermediateCode(cb.create());							
							RESULT = dt; 
						:};	


decl_variables ::= VAR secuencia_variables:sv decl_subprogramas:ds 
						{: 
							DeclaracionVariables dv = new DeclaracionVariables();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(sv.getIntermediateCode());
							cb.addQuadruples(ds.getIntermediateCode());
							dv.setIntermediateCode(cb.create());							
							RESULT = dv; 
						:}
		| decl_subprogramas:ds 
						{: 
							DeclaracionVariables dv = new DeclaracionVariables();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(ds.getIntermediateCode());
							dv.setIntermediateCode(cb.create());							
							RESULT = dv; 
						:};


decl_subprogramas ::= decl_subprogramas:d_sub decl_procedimiento:d_pro 
						{: 
							DeclaracionSubprogramas ds = new DeclaracionSubprogramas();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(d_sub.getIntermediateCode());
							cb.addQuadruples(d_pro.getIntermediateCode());
							ds.setIntermediateCode(cb.create());							
							RESULT = ds; 
						:} 
					| decl_subprogramas:d_sub decl_funcion:d_pro 
						{: 
							DeclaracionSubprogramas ds = new DeclaracionSubprogramas();							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(d_sub.getIntermediateCode());
							cb.addQuadruples(d_pro.getIntermediateCode());
							ds.setIntermediateCode(cb.create());							
							RESULT = ds; 
						:} 
		| {: RESULT = new DeclaracionSubprogramas(); :};

// Declaracion de constantes (del programa principal o de un subprograma)
secuencia_constantes ::= secuencia_constantes:sc constante:c 
							{: 
								SecuenciaConstantes sec = new SecuenciaConstantes();							
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								cb.addQuadruples(sc.getIntermediateCode());
								cb.addQuadruples(c.getIntermediateCode());
								sec.setIntermediateCode(cb.create());							
								RESULT = sec; 
							:} 
						| constante:c 
							{:
								SecuenciaConstantes sec = new SecuenciaConstantes();							
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								cb.addQuadruples(c.getIntermediateCode());
								sec.setIntermediateCode(cb.create());							
								RESULT = sec;  
							:};

constante ::= ID:id IGUAL literal_entero_o_logico:lel PUNTO_Y_COMA
			  {: 
				  	ScopeIF scope = scopeManager.getCurrentScope();
				  	SymbolTableIF sTabla = scope.getSymbolTable();
				  	String name = id.getLexema();				  	

				  	if (sTabla.containsSymbol (name)){
				  		semanticErrorManager.semanticFatalError("Ya existe una constante con ese nombre");
				  	}else{
				  		TypeIF tipoLiteral = lel.getTipo();
				  		TypeIF type;
				  		if (tipoLiteral instanceof TypeInteger) type = scopeManager.searchType("INTEGER");
				  	    else type = scopeManager.searchType("BOOLEAN");
				  		SymbolConstant sC = new SymbolConstant (scope,name,type);
				  		if (scope.getLevel()==0) {
				  			global_address = global_address+s_size;
				  			sC.setAddress(global_address);				  			
				  		}
				  		
				  		sTabla.addSymbol(sC);
				  		Variable var = new Variable(id.getLexema(),scope);
				  		Constante c = new Constante();
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruple("ASN", var, lel.getOperando());
						c.setIntermediateCode(cb.create());		
				  		
				  		RESULT = c;
				  	}
			  :};

literal_entero_o_logico ::= LITERAL_ENTERO:e
							{: 
								LiteralEnteroOLogico leol = new LiteralEnteroOLogico(scopeManager.searchType("INTEGER")); 
								Value val = new Value(e.getLexema());
								leol.setOperando(val);
								RESULT = leol;
							:}
			| literal_logico:ll
				{: 
					LiteralEnteroOLogico leol = new LiteralEnteroOLogico(scopeManager.searchType("BOOLEAN"));
					leol.setOperando(ll.getOperando());
					RESULT = leol; 
				:};

literal_logico ::= TRUE:b 
				{:  
					LiteralLogico litlog = new LiteralLogico();
					Value val = new Value(1);
					litlog.setOperando(val);					
					RESULT = litlog; 
				:}
		| FALSE:b 
				{:  
					LiteralLogico litlog = new LiteralLogico();
					Value val = new Value(0);
					litlog.setOperando(val);					
					RESULT = litlog; 
				:};

// Declaracion de tipos (del programa principal o de un subprograma)
secuencia_tipos ::= secuencia_tipos tipo | tipo {: RESULT = new SecuenciaTipos(); :};

tipo ::= ID:id IGUAL RECORD secuencia_campos_registro:cr END PUNTO_Y_COMA 
         {:
         	ScopeIF scope = scopeManager.getCurrentScope();
         	
         	if (scope.getSymbolTable().containsSymbol(id.getLexema()))
         		semanticErrorManager.semanticFatalError("Ya existe un registro con ese nombre en el mismo ambito");
            else{
            	TypeTableIF tablaT = scope.getTypeTable();
            	SymbolTableIF tablaS = scope.getSymbolTable();            	            	
            	TypeRecord registro = new TypeRecord(scope,id.getLexema());
            	registro.setCampos(cr.getRegistros());
            	tablaT.addType(id.getLexema(), registro);
            	RESULT = new Tipo(registro);
            }
         :};

secuencia_campos_registro ::= secuencia_campos_registro:sc campo_registro:cr 
			{:				
				if (sc.contieneCampo(cr.getNombre())){
					semanticErrorManager.semanticFatalError("Ya existe un campo con el mismo nombre en el registro");
				}else{
				 	sc.addRegistro(cr.getNombre(),cr);
					RESULT = new SecuenciaCamposRegistro(sc.getRegistros());
				}	
			:}
			| campo_registro:c
			{:				
				RESULT  = new SecuenciaCamposRegistro(c);
			:};

campo_registro ::= ID:id DOS_PUNTOS tipo_primitivo:tp PUNTO_Y_COMA {:
				   	  RESULT = new CampoRegistro(id.getLexema(),tp.getTipo());				   
				   :};

tipo_primitivo ::= INTEGER:id {: RESULT= new TipoPrimitivo(scopeManager.searchType("INTEGER")); :}
		| BOOLEAN:id  {: RESULT= new TipoPrimitivo(scopeManager.searchType("BOOLEAN")); :}
		| CIRCUNFLEJO INTEGER {: RESULT= new TipoPrimitivo(scopeManager.searchType("POINTER")); :};

// Declaracion de variables (del programa principal o de un subprograma)
secuencia_variables ::= secuencia_variables variabl {: RESULT = new SecuenciaVariables(); :}
	| variabl {: RESULT = new SecuenciaVariables(); :}; 

variabl ::= secuencia_IDs:sid DOS_PUNTOS tipo_datos:td PUNTO_Y_COMA
			{:
				List<String> ids = sid.getIDs();
				ScopeIF scope = scopeManager.getCurrentScope();
				SymbolTableIF sTable = scope.getSymbolTable();	
				
				for(String s: ids){					
					if(!(sTable.containsSymbol(s))){
						SymbolVariable sV = new SymbolVariable(scope,s,td.getTipo());
						if (scope.getLevel()==0) {
				  			global_address = global_address+s_size;
				  			sV.setAddress(global_address);				  			
				  		}
						sTable.addSymbol(s,sV);		
					}else{
						semanticErrorManager.semanticFatalError("Variable ya creada en el mismo ambito");
					}
				}				
				RESULT = new Variabl();									
			:};

secuencia_IDs ::= secuencia_IDs:sid COMA ID:id
		{:	
			if (sid.contiene(id.getLexema())){
				semanticErrorManager.semanticFatalError("Mas de una variable creada con el mismo nombre");
			}else{
				sid.addField(id.getLexema());
				RESULT = new SecuenciaIDs(sid.getIDs());
			}			
		:}
		| ID:id {: RESULT = new SecuenciaIDs(id.getLexema()); :};

tipo_datos ::= tipo_primitivo:tp {: RESULT = new TipoDatos(tp.getTipo()); :} 
		| ID:id 
			{: 
				if(!scopeManager.containsType(id.getLexema()))
					semanticErrorManager.semanticFatalError("No existe el tipo " + id.getLexema());	
				RESULT = new TipoDatos(scopeManager.searchType(id.getLexema())); 
			:};

// Declaracion de procedimientos
decl_procedimiento ::= PROCEDURE ID:id decl_parametros:dparam 
					{:
					   if(!scopeManager.containsSymbol(id.getLexema())){
					   	   ScopeIF scope = scopeManager.getCurrentScope();					   	   
					   	   TypeProcedure tF = new TypeProcedure(scope,id.getLexema());
					   	   SymbolProcedure sP = new SymbolProcedure(scope,id.getLexema(),tF);						   	   
					   	   scope.getSymbolTable().addSymbol(sP);
					   	   scope.getTypeTable().addType(tF);	
					   	   
				           ScopeIF nScope = scopeManager.openScope(id.getLexema());
				           SymbolTableIF nTabla =  nScope.getSymbolTable();
				           TypeTableIF nTTabla = nScope.getTypeTable();		           
				           				           
				           for (Parametro p : dparam.getParametros()){
				           		List<String> ids = p.getSecuenciaIDs().getIDs();
				           		tF.addParametro(p);
				           		
				           		for (String s: ids){									
									if(!(nTabla.containsSymbol(s))){
										SymbolParameter simboloParametro = new SymbolParameter(nScope,s,p.getTipo());
										nTabla.addSymbol(s,simboloParametro);	
										tF.addId();	
									}else{
										semanticErrorManager.semanticFatalError("Parametro ya creado en el mismo ambito");
									}
								}	
				           }	
			           }else{
			           	   semanticErrorManager.semanticFatalError("Nombre del procedimiento ya utilizado");
			           }						
					:} PUNTO_Y_COMA declaraciones:dec bloque:bloq PUNTO_Y_COMA {: 								
						ScopeIF scope = scopeManager.getCurrentScope();
						DeclaracionProcedimiento proc = new DeclaracionProcedimiento(); 
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						Procedure p = new Procedure(scope.getName(), scope);
						LabelIF label = p.getCodeLabel();
						cb.addQuadruple("INL", label);
						cb.addQuadruples(dec.getIntermediateCode());
						cb.addQuadruples(bloq.getIntermediateCode());
						proc.setIntermediateCode(cb.create());
						scopeManager.closeScope(); 
						RESULT = proc;
					:};	

decl_parametros ::= PARENT_ABRIR secuencia_parametros:sp PARENT_CERRAR {: RESULT = new DeclaracionParametros(sp.getParametros()); :} 
		 | PARENT_ABRIR PARENT_CERRAR {: RESULT = new DeclaracionParametros(); :};

secuencia_parametros ::= secuencia_parametros:sp PUNTO_Y_COMA parametro:p
						{:
							if (sp.contiene(p)){
								semanticErrorManager.semanticFatalError("Ya existe un parametro con el mismo nombre");
							}else{
								sp.addParametro(p);
								RESULT = new SecuenciaParametros(sp.getParametros());
							}
						:}
			| parametro:p {: RESULT = new SecuenciaParametros(p); :};

parametro ::= secuencia_IDs:sid DOS_PUNTOS tipo_primitivo:tp {: RESULT = new Parametro(sid,tp.getTipo()); :};

// Declaracion de funcion 
decl_funcion ::= FUNCTION ID:id decl_parametros:dparam DOS_PUNTOS tipo_primitivo:tp  PUNTO_Y_COMA 
					{:
					   if(!scopeManager.containsSymbol(id.getLexema())){
					   	   ScopeIF scope = scopeManager.getCurrentScope();
					   	   TypeFunction tF = new TypeFunction(scope,id.getLexema(),tp.getTipo());
					   	   SymbolFunction sF = new SymbolFunction(scope,id.getLexema(),tF);						   	   
					   	   scope.getSymbolTable().addSymbol(sF);	
					   	   scope.getTypeTable().addType(tF);

				           ScopeIF nScope = scopeManager.openScope(id.getLexema());
				           SymbolTableIF nTabla =  nScope.getSymbolTable();
				           TypeTableIF nTTabla = nScope.getTypeTable();	
				           				           
				           for (Parametro p : dparam.getParametros()){
				           		List<String> ids = p.getSecuenciaIDs().getIDs();
				           		tF.addParametro(p);
				           		
				           		for (String s: ids){
									
									if(!(nTabla.containsSymbol(s))){
										SymbolParameter simboloParametro = new SymbolParameter(nScope,s,p.getTipo());
										nTabla.addSymbol(s,simboloParametro);	
										tF.addId();
									}else{
										semanticErrorManager.semanticFatalError("Parametro ya creado en el mismo ambito");
									}
								}	
				           }	
			           }else{
			           	   semanticErrorManager.semanticFatalError("Nombre de la funcion ya utilizado");
			           }						
					:}declaraciones:dec bloque:bloq  PUNTO_Y_COMA{: 					
						
						ScopeIF scope = scopeManager.getCurrentScope();
						DeclaracionFuncion func = new DeclaracionFuncion(); 
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						Procedure p = new Procedure(scope.getName(), scope);
						LabelIF label = p.getCodeLabel();
						cb.addQuadruple("INL", label);
						cb.addQuadruples(dec.getIntermediateCode());
						cb.addQuadruples(bloq.getIntermediateCode());
						func.setIntermediateCode(cb.create());
						scopeManager.closeScope(); 
						RESULT = func;
					:};

// Llamada a funcion o procedimiento (se diferencia en el analisis semantico de la llamada)
llamada_subprograma ::= ID:id PARENT_ABRIR secuencia_parametros_llamada:spl PARENT_CERRAR 
						{:
							ScopeIF scope = scopeManager.getCurrentScope();
							if (!scopeManager.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
							}else{
								SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
								TypeIF tipo = simbolo.getType();
								if (!(tipo instanceof TypeFunction) && !(tipo instanceof TypeProcedure)){		
									semanticErrorManager.semanticFatalError(id.getLexema() + " no es un subprograma");									
								}else{									
									TypeProcedure funcion = (TypeProcedure) tipo;
									if(funcion.getNumIds()!=spl.getParametros().size()){	
										semanticErrorManager.semanticFatalError("Numero de parametros incorrecto");	
									}
									if(!funcion.compararParametros(spl.getParametros())){											
										semanticErrorManager.semanticFatalError("No coinciden los tipos");
									}else{	
										LlamadaSubprograma llamada = new LlamadaSubprograma(id.getLexema());
										IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);	
										ScopeIF scopeSub = scopeManager.searchSymbol(id.getLexema()).getScope();
										Procedure proc = new Procedure (id.getLexema(),scopeSub);
										cb.addQuadruple("CALL", proc);	
										llamada.setIntermediateCode(cb.create());											
									 	RESULT = llamada;
									}									
								}
							}
						:}
		| ID:id PARENT_ABRIR PARENT_CERRAR
			{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
					TypeIF tipo = simbolo.getType();
					if (!(tipo instanceof TypeFunction) && !(tipo instanceof TypeProcedure)){	
						semanticErrorManager.semanticFatalError(id.getLexema() + " no es una funcion");									
					}else{
						TypeProcedure funcion = (TypeProcedure) tipo;
						if (!(funcion.getParametros().size()==0)){
							semanticErrorManager.semanticFatalError("Se esperaban parametros de entrada");
						}else{
							LlamadaSubprograma llamada = new LlamadaSubprograma();
							IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);	
							cb.addQuadruple("CALL", null);	
							llamada.setIntermediateCode(cb.create());							
						 	RESULT = llamada;
						}
					}
				}
			:};

secuencia_parametros_llamada ::= secuencia_parametros_llamada:spl COMA exp:e 
						{:
							RESULT = new SecuenciaParametrosLlamada(spl.getParametros(), e);						
						:}
				 | exp:e {: RESULT = new SecuenciaParametrosLlamada(e); :};

// Expresiones
exp ::= LITERAL_ENTERO:e 
		{:
			ScopeIF scope = scopeManager.getCurrentScope();
					
			Expresion exp = new Expresion (scopeManager.searchType("INTEGER"));
			Value val = new Value(e.getLexema());
			exp.setOperando(val);
							
			RESULT = exp;	
		:}
	| ID:id {:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
					
					Expresion exp = new Expresion (simbolo.getType());
					Variable var = new Variable(id.getLexema(),scope);
					exp.setOperando(var);
									
					RESULT = exp;		
				}
			:}	
	| ID:id CIRCUNFLEJO 
		{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{					
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());					
			
					if (!simbolo.getType().getName().equals("POINTER")){
						semanticErrorManager.semanticFatalError(id.getLexema() + " no es un puntero");
					}else{				
						Expresion exp = new Expresion (scopeManager.searchType("INTEGER"));
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						
						TemporalFactory tf =new TemporalFactory(scope);
						Temporal temp = (Temporal) tf.create();
                        
						Variable var = new Variable(id.getLexema(),scope);
						
						cb.addQuadruple("MVP", temp, var);                                    
						exp.setIntermediateCode(cb.create());
						exp.setOperando(temp);
										
						RESULT = exp;
					}
				}
		:}
	| ID:i1 PUNTO ID:i2 
		{:				
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(i1.getLexema())){
					semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
				}else{							
					SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
					TypeRecord registro = (TypeRecord)simbolo.getType();						
					if (!registro.contieneCampo(i2.getLexema())){
						semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
					}else{
						HashMap<String,CampoRegistro> campos = registro.getCampos();
						TypeIF tipoI2 = campos.get(i2.getLexema()).getTipo();	
						
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);						
						Expresion exp = new Expresion (tipoI2,i2.getLine(),i2.getColumn()); 
						TemporalFactory tf = new TemporalFactory(scope);
                        Temporal temp = (Temporal) tf.create();
                        
                        Variable var1 = new Variable(i1.getLexema(),scope);
                        Variable var2 = new Variable(i2.getLexema(),scope);
                        
                        cb.addQuadruple("REG", temp, var1, var2);
                        
                        exp.setOperando(temp);
                        exp.setIntermediateCode(cb.create());
						
						RESULT = exp; 
					}
				}
		:}
	| ID:i1 PUNTO ID:i2 CIRCUNFLEJO 
		{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(i1.getLexema())){
					semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
				}else{	
					if (!scopeManager.containsSymbol(i2.getLexema())){
					semanticErrorManager.semanticFatalError(i2.getLexema() + " no definido");
					}else{	
						SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
						TypeRecord registro = (TypeRecord)simbolo.getType();						
						if (!registro.contieneCampo(i2.getLexema())){
							semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
						}else{
							HashMap<String,TypeIF> campos = registro.getCampos();
							TypeIF tipoI2 = campos.get(i2.getLexema());
							if (!tipoI2.getName().equals("POINTER")){
								semanticErrorManager.semanticFatalError(i2.getLexema() + " no es un puntero");
							}else{							
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);						
								Expresion exp = new Expresion (tipoI2,i2.getLine(),i2.getColumn()); 
								TemporalFactory tf = new TemporalFactory(scope);
								Temporal temp = (Temporal) tf.create();
								
								Variable var1 = new Variable(i1.getLexema(),scope);
								Variable var2 = new Variable(i2.getLexema(),scope);
								
								cb.addQuadruple("MVP_REG", var1, var2);
								
								exp.setOperando(temp);
								exp.setIntermediateCode(cb.create());
								
								RESULT = exp;  
							}
						}	
					}
				}
		:}
	| ARROBA ID:id 
			{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{
					Expresion exp = new Expresion (scopeManager.searchType("POINTER"),id.getLine(),id.getColumn());
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					TemporalFactory tf = new TemporalFactory(scope);
					Temporal temp = (Temporal) tf.create();
					Variable var = new Variable(id.getLexema(),scope);
					exp.setOperando(temp);
					cb.addQuadruple("MVA", temp, var);
					exp.setIntermediateCode(cb.create());
					RESULT = exp;
				}
			:}
	| ARROBA ID:i1 PUNTO ID:i2
		{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(i1.getLexema())){
					semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
				}else{	
					if (!scopeManager.containsSymbol(i2.getLexema())){
					semanticErrorManager.semanticFatalError(i2.getLexema() + " no definido");
					}else{	
						SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
						TypeRecord registro = (TypeRecord)simbolo.getType();						
						if (!registro.contieneCampo(i2.getLexema())){
							semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
						}else{
							HashMap<String,TypeIF> campos = registro.getCampos();
							TypeIF tipoI2 = campos.get(i2.getLexema());
							
							Expresion exp = new Expresion (scopeManager.searchType("POINTER"),i1.getLine(),i1.getColumn());
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							TemporalFactory tf = new TemporalFactory(scope);
							Temporal temp = (Temporal) tf.create();
							Variable var1 = new Variable(i1.getLexema(),scope);
							Variable var2 = new Variable(i2.getLexema(),scope);
							exp.setOperando(temp);
							cb.addQuadruple("MVA_REG", var1, var2, temp);
							exp.setIntermediateCode(cb.create());
							RESULT = exp;
						}	
					}
				}
		:} 
	| TRUE {:
				Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"));
				Value val = new Value(1);
				exp.setOperando(val);
				RESULT = exp;
			:}
	| FALSE {:
				Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"));
				Value val = new Value(0);
				exp.setOperando(val);
				RESULT = exp;
			:}
	| exp:e1 MENOS exp:e2 
		{:
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			if (!t1.getName().equals("INTEGER") || !t2.getName().equals("INTEGER")){
				semanticErrorManager.semanticFatalError("Tipos no compatibles con el operador '-'");
			}else{			
				ScopeIF scope = scopeManager.getCurrentScope();
				
				Expresion exp = new Expresion (scopeManager.searchType("INTEGER"));
				
				TemporalFactory tf = new TemporalFactory(scope);
				Temporal temp = (Temporal) tf.create();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				List cod1 = e1.getIntermediateCode();
				List cod2 = e2.getIntermediateCode();
				
				cb.addQuadruples (cod1);
				cb.addQuadruples (cod2);
						
				cb.addQuadruple ("SUB", temp, e1.getOperando(), e2.getOperando());
				
				List cod=cb.create ();
				exp.setIntermediateCode (cod); 
				exp.setOperando(temp);
				
				RESULT = exp;
			}
		:}
	| exp:e1 OR exp:e2 
		 {:	
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			
			if (!t1.getName().equals("BOOLEAN") || !t2.getName().equals("BOOLEAN")){
				semanticErrorManager.semanticFatalError("Tipos no compatibles para la disyuncion");
			}else{		
				ScopeIF scope = scopeManager.getCurrentScope();
				
				Expresion exp = new Expresion (scopeManager.searchType("BOOLEAN"));
				
				TemporalFactory tf = new TemporalFactory(scope);
				Temporal temp = (Temporal) tf.create();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				List cod1 = e1.getIntermediateCode();
				List cod2 = e2.getIntermediateCode();
				
				cb.addQuadruples (cod1);
				cb.addQuadruples (cod2);
				
				cb.addQuadruple ("OR", temp, e1.getOperando(), e2.getOperando());
				
				List cod=cb.create ();
				exp.setIntermediateCode (cod); 
				exp.setOperando(temp);
								
				RESULT = exp;
			}
		:}	
	| exp:e1 MAYOR_QUE exp:e2 
		{:
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			
			if (!t1.getName().equals("INTEGER") || !t2.getName().equals("INTEGER")){
				semanticErrorManager.semanticFatalError("Tipos no compatibles con el operador >");
			}else{
				ScopeIF scope = scopeManager.getCurrentScope();
				
				Expresion exp = new Expresion (scopeManager.searchType("BOOLEAN"));
				
				TemporalFactory tf = new TemporalFactory(scope);
				Temporal temp = (Temporal) tf.create();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				List cod1 = e1.getIntermediateCode();
				List cod2 = e2.getIntermediateCode();
				
				cb.addQuadruples (cod1);
				cb.addQuadruples (cod2);
						
				cb.addQuadruple ("GT", e1.getOperando(), e2.getOperando(), temp);
				
				List cod=cb.create ();
				exp.setIntermediateCode (cod); 
				exp.setOperando(temp);
				
				RESULT = exp;
			}	
		:}
	| exp:e1 IGUAL exp:e2 
		{:
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			
			if (t1.getName() != t2.getName()){
				semanticErrorManager.semanticFatalError("Tipos no compatibles");
			}else{
				ScopeIF scope = scopeManager.getCurrentScope();
				
				Expresion exp = new Expresion (scopeManager.searchType("BOOLEAN"));
				
				TemporalFactory tf = new TemporalFactory(scope);
				Temporal temp = (Temporal) tf.create();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				List cod1 = e1.getIntermediateCode();
				List cod2 = e2.getIntermediateCode();
				
				cb.addQuadruples (cod1);
				cb.addQuadruples (cod2);
						
				cb.addQuadruple ("EQ", temp, e1.getOperando(), e2.getOperando());
				
				List cod=cb.create ();
				exp.setIntermediateCode (cod); 
				exp.setOperando(temp);
				
				RESULT = exp;					
			}	
		:}
	| PARENT_ABRIR exp:e PARENT_CERRAR 
		{:
			RESULT = e;
		:}
	| llamada_subprograma:ls 
	{: 		
		ScopeIF scope = scopeManager.getCurrentScope();
		Expresion exp = new Expresion(scopeManager.searchType(ls.getNombre())); 
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(ls.getIntermediateCode());
		exp.setIntermediateCode(cb.create());
		RESULT = exp; 
	:};


// Bloque de sentencias
bloque ::= BEGIN secuencia_sentencias:sc END 
			{: 
				ScopeIF scope = scopeManager.getCurrentScope();
				Bloque b = new Bloque();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				cb.addQuadruples(sc.getIntermediateCode());
				b.setIntermediateCode(cb.create());
				RESULT = b; 
			:}
	| BEGIN END {: RESULT = new Bloque(); :};

secuencia_sentencias ::= secuencia_sentencias:sc  sentencia:s 
							{: 
								SecuenciaSentencias ss = new SecuenciaSentencias();
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								cb.addQuadruples(sc.getIntermediateCode());
								cb.addQuadruples(s.getIntermediateCode());
								ss.setIntermediateCode(cb.create());
								RESULT = ss;  
							:} 
						| sentencia:s 
							{: 
								SecuenciaSentencias ss = new SecuenciaSentencias();
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								cb.addQuadruples(s.getIntermediateCode());
								ss.setIntermediateCode(cb.create());
								RESULT = ss;  
							:};

sentencia ::= sentencia_asignacion:s 
				{: 
					Sentencia ss = new Sentencia();
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(s.getIntermediateCode());
					ss.setIntermediateCode(cb.create());
					RESULT = ss;  
				:}
		| sentencia_if:s 
				{: 
					Sentencia ss = new Sentencia();
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(s.getIntermediateCode());
					ss.setIntermediateCode(cb.create());
					RESULT = ss;  
				:}
		| sentencia_for:s 
				{: 
					Sentencia ss = new Sentencia();
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(s.getIntermediateCode());
					ss.setIntermediateCode(cb.create());
					RESULT = ss;  
				:}
		| llamada_subprograma:s PUNTO_Y_COMA 
				{: 
					Sentencia ss = new Sentencia();
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(s.getIntermediateCode());
					ss.setIntermediateCode(cb.create());
					RESULT = ss;  
				:}
		| sentencia_write:s 
				{: 
					Sentencia ss = new Sentencia();
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(s.getIntermediateCode());
					ss.setIntermediateCode(cb.create());
					RESULT = ss;  
				:};


sentencia_asignacion ::= sentencia_asignacion_izq:sai DOS_PUNTOS_IGUAL exp:e PUNTO_Y_COMA
						{:
							ScopeIF scope = scopeManager.getCurrentScope();
							
							if (!scopeManager.containsSymbol(sai.getId())){
								semanticErrorManager.semanticFatalError("Simbolo " + sai.getId() + " no definido");
							}else{
								SymbolIF simbolo = scopeManager.searchSymbol(sai.getId());
								TypeIF tipo = simbolo.getType();
								
								if (tipo instanceof TypeInteger){	
									if(!(e.getTipo() instanceof TypeInteger) && !(e.getTipo() instanceof TypeFunction)){ 
										semanticErrorManager.semanticFatalError("Tipos incompatibles. Integer no es compatible con " + e.getTipo().getName());
									}								
								}else if (tipo instanceof TypeBoolean && !(e.getTipo() instanceof TypeFunction)){	
									if(!(e.getTipo() instanceof TypeBoolean)){
										semanticErrorManager.semanticFatalError("Tipos incompatibles");
									}																										
								}else if (tipo instanceof TypeRecord){	
									TypeRecord tipoRegistro = (TypeRecord)tipo;
									TypeIF tipoCampo = tipoRegistro.tipoCampo(sai.getCampo());
									if (tipoCampo instanceof TypeInteger && (!(e.getTipo() instanceof TypeInteger) && !(e.getTipo() instanceof TypeFunction))){	
										semanticErrorManager.semanticFatalError("Tipos incompatibles");											
									}else if (tipoCampo instanceof TypeBoolean && (!(e.getTipo() instanceof TypeBoolean) && !(e.getTipo() instanceof TypeFunction))){
										semanticErrorManager.semanticFatalError("Tipos incompatibles");
									}																
								}else{	//PUNTERO	
									if(!(e.getTipo() instanceof TypeInteger) && !(e.getTipo() instanceof TypeFunction)){ 
										semanticErrorManager.semanticFatalError("Tipos incompatibles. Integer no es compatible con " + e.getTipo().getName());
									}
								}							
							}	
							SentenciaAsignacion sa = new SentenciaAsignacion();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(sai.getIntermediateCode());
							cb.addQuadruples(e.getIntermediateCode());
							cb.addQuadruple("ASN",sai.getOperando(), e.getOperando());
							sa.setIntermediateCode(cb.create());																				
							RESULT = sa; 
						:};

sentencia_asignacion_izq ::= ID:id 
							{:
								ScopeIF scope = scopeManager.getCurrentScope();
								if (!scopeManager.containsSymbol(id.getLexema())){
									semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
								}else{
									SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
									
									SentenciaAsignacionIzq sai = new SentenciaAsignacionIzq (simbolo.getType(),id.getLexema());
									Variable var = new Variable(id.getLexema(),scope);
									sai.setOperando(var);
													
									RESULT = sai;		
								}
							:}
			| ID:id CIRCUNFLEJO {: 	
									ScopeIF scope = scopeManager.getCurrentScope();		
									SentenciaAsignacionIzq sai = new SentenciaAsignacionIzq (scopeManager.searchType("INTEGER"));
									IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
									
									TemporalFactory tf =new TemporalFactory(scope);
									Temporal temp = (Temporal) tf.create();
			                        
									Variable var = new Variable(id.getLexema(),scope);
									
									cb.addQuadruple("MVP", temp, var);                                    
									sai.setIntermediateCode(cb.create());
									sai.setOperando(temp);
													
									RESULT = sai;
								:}			
			| ID:i1 PUNTO ID:i2 
								{: 								
									ScopeIF scope = scopeManager.getCurrentScope();
									
									if (!scopeManager.containsSymbol(i1.getLexema())){
										semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
									}else{							
										SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
										TypeRecord registro = (TypeRecord)simbolo.getType();						
										if (!registro.contieneCampo(i2.getLexema())){
											semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
										}else{
											HashMap<String,CampoRegistro> campos = registro.getCampos();
											TypeIF tipoI2 = campos.get(i2.getLexema()).getTipo();	
											IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);						
											SentenciaAsignacionIzq sai = new SentenciaAsignacionIzq (i1.getLexema(),i2.getLexema()); 
											TemporalFactory tf = new TemporalFactory(scope);
					                        Temporal temp = (Temporal) tf.create();
					                        Variable var1 = new Variable(i1.getLexema(),scope);
					                        Variable var2 = new Variable(i2.getLexema(),scope);
					                        					                        
					                        cb.addQuadruple("REG", temp,  var1, var2);
					                        
					                        sai.setOperando(temp);
					                        sai.setIntermediateCode(cb.create());
											
											RESULT = sai;	
										}
									}
								:}
			| ID:i1 PUNTO ID:i2 CIRCUNFLEJO 
								{:
									ScopeIF scope = scopeManager.getCurrentScope();
									if (!scopeManager.containsSymbol(i1.getLexema())){
										semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
									}else{							
										SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
										TypeRecord registro = (TypeRecord)simbolo.getType();						
										if (!registro.contieneCampo(i2.getLexema())){
											semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
										}else{
											HashMap<String,CampoRegistro> campos = registro.getCampos();
											TypeIF tipoI2 = campos.get(i2.getLexema()).getTipo();	
											IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);						
											SentenciaAsignacionIzq sai = new SentenciaAsignacionIzq (i1.getLexema(),i2.getLexema()); 
											TemporalFactory tf = new TemporalFactory(scope);
					                        Temporal temp = (Temporal) tf.create();
					                        
					                        Variable var1 = new Variable(i1.getLexema(),scope);
					                        Variable var2 = new Variable(i2.getLexema(),scope);
					                        
					                        cb.addQuadruple("REG_POINT", temp, var1, var2);
					                        
					                        sai.setOperando(temp);
					                        sai.setIntermediateCode(cb.create());
											
											RESULT = sai;	
										}
									}									
								:};

// Sentencia de control de flujo condicional if-then-else
sentencia_if ::= IF PARENT_ABRIR exp:e PARENT_CERRAR THEN sentencias_then_else_for:stef parte_else:pe
				{:	
					if(!(e.getTipo() instanceof TypeBoolean)){
						semanticErrorManager.semanticFatalError("La expresion de la condicion debe ser de tipo Boolean");
					}
					SentenciaIF sentencia = new SentenciaIF();
					ScopeIF scope = scopeManager.getCurrentScope();
					LabelFactory lf = new LabelFactory();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					LabelIF l1 = lf.create();
					LabelIF l2 = lf.create();
					cb.addQuadruples(e.getIntermediateCode());
					cb.addQuadruple("BZ", l1);
					cb.addQuadruples(stef.getIntermediateCode());
					cb.addQuadruple("BR", l2);
					cb.addQuadruple("INL", l1);
					cb.addQuadruples(pe.getIntermediateCode());
					cb.addQuadruple("INL", l2);
					
					sentencia.setIntermediateCode(cb.create());
					
					RESULT = sentencia;					
				:};	

sentencias_then_else_for ::= bloque:b PUNTO_Y_COMA 
								{: 
									ScopeIF scope = scopeManager.getCurrentScope();
									SentenciasThenElseFor stef = new SentenciasThenElseFor();
									IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
									cb.addQuadruples(b.getIntermediateCode());
									stef.setIntermediateCode(cb.create());
									RESULT = stef; 
								:}
			| sentencia:s 
				{: 
					ScopeIF scope = scopeManager.getCurrentScope();
					SentenciasThenElseFor stef = new SentenciasThenElseFor();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(s.getIntermediateCode());
					stef.setIntermediateCode(cb.create());
					RESULT = stef; 
				:};

parte_else ::= ELSE sentencias_then_else_for:stef 
				{: 
					ScopeIF scope = scopeManager.getCurrentScope();
					ParteElse pe = new ParteElse();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(stef.getIntermediateCode());
					pe.setIntermediateCode(cb.create());
					RESULT = pe; 
				:}
		| {: RESULT = new ParteElse(); :};

// Sentencia de control de flujo iterativo for (las sentencias dentro de un bucle for siguen las mismas normas que para el if)
sentencia_for ::= FOR PARENT_ABRIR ID:id DOS_PUNTOS_IGUAL exp:e1 TO exp:e2 PARENT_CERRAR DO sentencias_then_else_for:sent
					{:
						ScopeIF scope = scopeManager.getCurrentScope();
						if (!scopeManager.containsSymbol(id.getLexema())){
							semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
						}else{
							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
							if (!simbolo.getType().getName().equals("INTEGER")){	
								semanticErrorManager.semanticFatalError(id.getLexema() + " debe ser INTEGER");	
							}else{
								TypeIF t1 = e1.getTipo();
								TypeIF t2 = e2.getTipo();
								
								if (!t1.getName().equals("INTEGER") || !t2.getName().equals("INTEGER")){
									semanticErrorManager.semanticFatalError("Las expresiones deben ser INTEGER");	
								}
								SentenciaFor sf = new SentenciaFor();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								LabelFactory lf = new LabelFactory();
								TemporalFactory tf = new TemporalFactory(scope);
								TemporalIF temp = tf.create();
								
								Variable var = new Variable(id.getLexema(), scope);
								
								LabelIF l1 = lf.create();
								LabelIF l2 = lf.create();
								
								cb.addQuadruples(e1.getIntermediateCode());
								cb.addQuadruple("ASN",var, e1.getOperando());
								cb.addQuadruples(e2.getIntermediateCode());
								cb.addQuadruple("ASN",temp, e2.getOperando());								
								cb.addQuadruple("INL" , l1);
								cb.addQuadruple("CMP", var, temp);
								cb.addQuadruple("BN", l2);
								cb.addQuadruples(sent.getIntermediateCode());
								cb.addQuadruple("INC", var);
								cb.addQuadruple("BR" , l1);
								cb.addQuadruple("INL" , l2);
								sf.setIntermediateCode(cb.create());
								RESULT = sf;
							}								
						}					
					:};

// Sentencias write y writeln
sentencia_write ::= WRITE PARENT_ABRIR parametro_write:pw PARENT_CERRAR PUNTO_Y_COMA 
						{: 
							SentenciaWrite swrite = new SentenciaWrite();
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruples(pw.getIntermediateCode());
							cb.addQuadruple("WRITE", pw.getOperando());
							swrite.setIntermediateCode(cb.create());
							RESULT = swrite; 
						:}
		| WRITELN PARENT_ABRIR PARENT_CERRAR PUNTO_Y_COMA 
						{: 
							SentenciaWrite swrite = new SentenciaWrite();
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							cb.addQuadruple("WRITELN", null);
							swrite.setIntermediateCode(cb.create());
							RESULT = swrite; 
						:};

parametro_write ::= exp:e
					{: 
						ParametroWrite pw = new ParametroWrite();			
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(e.getIntermediateCode());
						pw.setIntermediateCode(cb.create());
						pw.setOperando(e.getOperando());			
						RESULT = pw;
					:} 
		| LITERAL_CADENA:lit 
			{: 	
				ParametroWrite pw = new ParametroWrite();			
				ScopeIF scope = scopeManager.getCurrentScope();
				textos.add(lit.getLexema());
				Value valor = new Value(lit.getLexema());
				pw.setOperando(valor);			
				RESULT = pw; 
			:}
		| {: RESULT = new ParametroWrite(); :};
			