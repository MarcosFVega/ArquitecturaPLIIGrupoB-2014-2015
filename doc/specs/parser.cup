package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;
// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales

// Constantes literales
terminal Token LITERAL_ENTERO;
terminal Token LITERAL_CADENA;

// Identificadores
terminal Token ID;

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token DO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PROGRAM;
terminal Token RECORD;
terminal Token THEN;
terminal Token TO;
terminal Token TRUE;
terminal Token TYPE;
terminal Token VAR;
terminal Token WRITE;
terminal Token WRITELN;

// Delimitadores
terminal Token PARENT_ABRIR;
terminal Token PARENT_CERRAR;
terminal Token COMA;
terminal Token PUNTO_Y_COMA;
terminal Token DOS_PUNTOS;
terminal Token IGUAL;

// Operadores
terminal Token MENOS;
terminal Token MAYOR_QUE;
terminal Token DOS_PUNTOS_IGUAL;
terminal Token PUNTO;
terminal Token CIRCUNFLEJO;
terminal Token ARROBA;

// Declaracion de no terminales
// no modificar los propuestos
non terminal program;
non terminal Axiom axiom;
non terminal Declaraciones declaraciones;
non terminal Bloque bloque;
non terminal SecuenciaSentencias secuencia_sentencias;
non terminal Sentencia sentencia;
non terminal DeclaracionTipos decl_tipos;
non terminal DeclaracionVariables decl_variables;
non terminal DeclaracionSubprogramas decl_subprogramas;
non terminal SecuenciaConstantes secuencia_constantes;
non terminal Constante constante;
non terminal LiteralEnteroOLogico literal_entero_o_logico;
non terminal Token literal_logico;
non terminal SecuenciaTipos secuencia_tipos;
non terminal Tipo tipo;
non terminal SecuenciaVariables secuencia_variables;
non terminal Variabl variabl;
non terminal SecuenciaIDs secuencia_IDs;
non terminal TipoDatos tipo_datos;
non terminal TipoPrimitivo tipo_primitivo;
non terminal SecuenciaCamposRegistro secuencia_campos_registro;
non terminal CampoRegistro campo_registro;
non terminal DeclaracionProcedimiento decl_procedimiento;
non terminal DeclaracionFuncion decl_funcion;
non terminal DeclaracionParametros decl_parametros;
non terminal SecuenciaParametros secuencia_parametros;
non terminal Parametro parametro;
non terminal Expresion exp;
non terminal SecuenciaParametrosLlamada secuencia_parametros_llamada;
non terminal SentenciaAsignacion sentencia_asignacion;
non terminal SentenciaAsignacionIzq sentencia_asignacion_izq;
non terminal LlamadaSubprograma llamada_subprograma;
non terminal SentenciaIF sentencia_if;
non terminal SentenciasThenElseFor sentencias_then_else_for;
non terminal SentenciaFor sentencia_for;
non terminal SentenciaWrite sentencia_write;
non terminal ParametroWrite parametro_write;
non terminal ParteElse parte_else;

// Declaracion de relaciones de asociatividad
// Declaracion de relaciones de precedencia

precedence left 		ELSE;
precedence nonassoc		MAYOR_QUE, IGUAL;
precedence left			MENOS, OR;
precedence left			PUNTO, PARENT_ABRIR, PARENT_CERRAR;

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir mas acciones semanticas
  		// Para la entrega de febrero pueden comentarse las sentencias siguientes:
  		List intermediateCode = ax.getIntermediateCode ();
		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);
  		
  		// CODIGO INTERMEDIO -- SALIDA POR PANTALLA
		syntaxErrorManager.syntaxInfo("-----------------");
		syntaxErrorManager.syntaxInfo("CODIGO INTERMEDIO");
		syntaxErrorManager.syntaxInfo("-----------------");
		Iterator it = intermediateCode.iterator();
		while ( it.hasNext() ) {
			syntaxErrorManager.syntaxInfo(it.next().toString());
		}
   :};


axiom ::= PROGRAM:prg ID:id 
		{:
           scopeManager.openScope(id.getLexema());
           ScopeIF scope = scopeManager.getCurrentScope();
           
           System.out.println("Entrando en el ambito: " + scope.getName());
           System.out.println("---------------------------------------------");
           
           //Insertar todos los tipos simples en la TT
		   TypeTableIF tablaTipos = scope.getTypeTable();
		   	
		   TypeSimple tipoBooleano = new TypeBoolean(scope);
		   tablaTipos.addType(tipoBooleano);
		   
		   TypeSimple tipoEntero = new TypeInteger(scope);
           tablaTipos.addType(tipoEntero);
           	
           TypePointer tipoPuntero = new TypePointer(scope,"POINTER");
           tablaTipos.addType(tipoPuntero);	           
           
		:} PUNTO_Y_COMA declaraciones:dec bloque:bloq PUNTO
			{:
				ScopeIF scope = scopeManager.getCurrentScope();				          				
				
                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                
                cb.addQuadruple("INICIAR",null);
                cb.addQuadruple("HALT", null);

                List intermediateCode = cb.create();                                 
                
                Axioma axi = new Axioma();
                axi.setIntermediateCode(intermediateCode);
                RESULT = axi;
               
			:}; 
		
// Las declaraciones incluyen, de forma opcional pero siempre en este orden:
// constantes, tipos, variables globales y subprogramas
declaraciones ::= CONST secuencia_constantes decl_tipos {: RESULT = new Declaraciones(); :}
		| decl_tipos {: RESULT = new Declaraciones(); :};

decl_tipos ::= TYPE secuencia_tipos decl_variables {: RESULT = new DeclaracionTipos(); :}
		| decl_variables {: RESULT = new DeclaracionTipos(); :};	


decl_variables ::= VAR secuencia_variables decl_subprogramas {: RESULT = new DeclaracionVariables(); :}
		| decl_subprogramas {: RESULT = new DeclaracionVariables(); :};


decl_subprogramas ::= decl_subprogramas decl_procedimiento {: RESULT = new DeclaracionSubprogramas(); :} 
		| decl_subprogramas decl_funcion {: RESULT = new DeclaracionSubprogramas(); :}
		| ;

// Declaracion de constantes (del programa principal o de un subprograma)
secuencia_constantes ::= secuencia_constantes constante {: RESULT = new SecuenciaConstantes(); :} 
						| constante {: RESULT = new SecuenciaConstantes(); :};

constante ::= ID:id IGUAL literal_entero_o_logico:lel PUNTO_Y_COMA
			  {: 
				  	ScopeIF scope = scopeManager.getCurrentScope();
				  	SymbolTableIF sTabla = scope.getSymbolTable();
				  	String name = id.getLexema();				  	

				  	if (sTabla.containsSymbol (name)){
				  		semanticErrorManager.semanticFatalError("Ya existe una constante con ese nombre");
				  	}else{
				  		TypeIF tipoLiteral = lel.getTipo();
				  		TypeIF type;
				  		if (tipoLiteral instanceof TypeInteger) type = scopeManager.searchType("INTEGER");
				  	    else type = scopeManager.searchType("BOOLEAN");
				  		SymbolConstant sC = new SymbolConstant (scope,name,type);
				  		sTabla.addSymbol(sC);
				  		semanticErrorManager.semanticInfo("AGREGADO CONSTANTE " + name + " A LA TABLA DE SiMBOLOS");
				  		
				  		RESULT = new Constante();
				  	}
			  :};

literal_entero_o_logico ::= LITERAL_ENTERO {: RESULT = new LiteralEnteroOLogico(scopeManager.searchType("INTEGER")); :}
			| literal_logico {: RESULT = new LiteralEnteroOLogico(scopeManager.searchType("BOOLEAN")); :};

literal_logico ::= TRUE:b {: RESULT = b; :}
		| FALSE:b {: RESULT = b; :};

// Declaracion de tipos (del programa principal o de un subprograma)
secuencia_tipos ::= secuencia_tipos tipo | tipo {: RESULT = new SecuenciaTipos(); :};

tipo ::= ID:id IGUAL RECORD secuencia_campos_registro:cr END PUNTO_Y_COMA 
         {:
         	ScopeIF scope = scopeManager.getCurrentScope();
         	
         	if (scope.getSymbolTable().containsSymbol(id.getLexema()))
         		semanticErrorManager.semanticFatalError("Ya existe un registro con ese nombre en el mismo ambito");
            else{
            	TypeTableIF tablaT = scope.getTypeTable();
            	SymbolTableIF tablaS = scope.getSymbolTable();            	            	
            	TypeRecord registro = new TypeRecord(scope,id.getLexema());
            	registro.setCampos(cr.getRegistros());
            	tablaT.addType(id.getLexema(), registro);
            	semanticErrorManager.semanticInfo("AGREGADO TIPO " + id.getLexema() + " A LA TABLA DE TIPOS");
            	RESULT = new Tipo(registro);
            }
         :};

secuencia_campos_registro ::= secuencia_campos_registro:sc campo_registro:cr 
			{:				
				if (sc.contieneCampo(cr.getNombre())){
					semanticErrorManager.semanticFatalError("Ya existe un campo con el mismo nombre en el registro");
				}else{
				 	sc.addRegistro(cr.getNombre(),cr);
					RESULT = new SecuenciaCamposRegistro(sc.getRegistros());
				}	
			:}
			| campo_registro:c
			{:				
				RESULT  = new SecuenciaCamposRegistro(c);
			:};

campo_registro ::= ID:id DOS_PUNTOS tipo_primitivo:tp PUNTO_Y_COMA {:
				   	  RESULT = new CampoRegistro(id.getLexema(),tp.getTipo());				   
				   :};

tipo_primitivo ::= INTEGER:id {: RESULT= new TipoPrimitivo(scopeManager.searchType("INTEGER")); :}
		| BOOLEAN:id  {: RESULT= new TipoPrimitivo(scopeManager.searchType("BOOLEAN")); :}
		| CIRCUNFLEJO INTEGER {: RESULT= new TipoPrimitivo(scopeManager.searchType("POINTER")); :};

// Declaracion de variables (del programa principal o de un subprograma)
secuencia_variables ::= secuencia_variables variabl {: RESULT = new SecuenciaVariables(); :}
	| variabl {: RESULT = new SecuenciaVariables(); :}; 

variabl ::= secuencia_IDs:sid DOS_PUNTOS tipo_datos:td PUNTO_Y_COMA
			{:
				List<String> ids = sid.getIDs();
				ScopeIF scope = scopeManager.getCurrentScope();
				SymbolTableIF sTable = scope.getSymbolTable();	
				
				for(String s: ids){					
					if(!(sTable.containsSymbol(s))){
						SymbolVariable sV = new SymbolVariable(scope,s,td.getTipo());
						sTable.addSymbol(s,sV);						
						semanticErrorManager.semanticInfo("AGREGADO SIMBOLO " + s + " DE TIPO " + td.getTipo().getName() + " A LA TABLA DE SIMBOLOS");						
					}else{
						semanticErrorManager.semanticFatalError("Variable ya creada en el mismo ambito");
					}
				}				
				RESULT = new Variabl();									
			:};

secuencia_IDs ::= secuencia_IDs:sid COMA ID:id
		{:	
			if (sid.contiene(id.getLexema())){
				semanticErrorManager.semanticFatalError("Mas de una variable creada con el mismo nombre");
			}else{
				sid.addField(id.getLexema());
				RESULT = new SecuenciaIDs(sid.getIDs());
			}			
		:}
		| ID:id {: RESULT = new SecuenciaIDs(id.getLexema()); :};

tipo_datos ::= tipo_primitivo:tp {: RESULT = new TipoDatos(tp.getTipo()); :} 
		| ID:id 
			{: 
				if(!scopeManager.containsType(id.getLexema()))
					semanticErrorManager.semanticFatalError("No existe el tipo " + id.getLexema());	
				RESULT = new TipoDatos(scopeManager.searchType(id.getLexema())); 
			:};

// Declaracion de procedimientos
decl_procedimiento ::= PROCEDURE ID:id decl_parametros:dparam 
					{:
					   if(!scopeManager.containsSymbol(id.getLexema())){
					   	   ScopeIF scope = scopeManager.getCurrentScope();					   	   
					   	   TypeProcedure tF = new TypeProcedure(scope,id.getLexema());
					   	   SymbolProcedure sP = new SymbolProcedure(scope,id.getLexema(),tF);						   	   
					   	   scope.getSymbolTable().addSymbol(sP);
					   	   scope.getTypeTable().addType(tF);	
					   	   semanticErrorManager.semanticInfo("AGREGADO SIMBOLO " + id.getLexema() + " A LA TABLA DE SiMBOLOS");	
					   	   
				           ScopeIF nScope = scopeManager.openScope(id.getLexema());
				           SymbolTableIF nTabla =  nScope.getSymbolTable();
				           TypeTableIF nTTabla = nScope.getTypeTable();		           
				           
				           System.out.println("Entrando en el ambito: " + nScope.getName());
           				   System.out.println("---------------------------------------------");
				           				           
				           for (Parametro p : dparam.getParametros()){
				           		List<String> ids = p.getSecuenciaIDs().getIDs();
				           		tF.addParametro(p);
				           		
				           		for (String s: ids){									
									if(!(nTabla.containsSymbol(s))){
										SymbolParameter simboloParametro = new SymbolParameter(scope,s,p.getTipo());
										nTabla.addSymbol(s,simboloParametro);	
										tF.addId();										
										semanticErrorManager.semanticInfo("AGREGADO SiMBOLO " + s + " A LA TABLA DE SiMBOLOS DE " + id.getLexema());
									}else{
										semanticErrorManager.semanticFatalError("Parametro ya creado en el mismo ambito");
									}
								}	
				           }	
			           }else{
			           	   semanticErrorManager.semanticFatalError("Nombre del procedimiento ya utilizado");
			           }						
					:} PUNTO_Y_COMA declaraciones bloque PUNTO_Y_COMA {: 					
						
						System.out.println("Saliendo del ambito: " + scopeManager.getCurrentScope().getName());
           				System.out.println("---------------------------------------------");
						scopeManager.closeScope(); 
						RESULT = new DeclaracionProcedimiento();
					:};	

decl_parametros ::= PARENT_ABRIR secuencia_parametros:sp PARENT_CERRAR {: RESULT = new DeclaracionParametros(sp.getParametros()); :} 
		 | PARENT_ABRIR PARENT_CERRAR {: RESULT = new DeclaracionParametros(); :};

secuencia_parametros ::= secuencia_parametros:sp PUNTO_Y_COMA parametro:p
						{:
							if (sp.contiene(p)){
								semanticErrorManager.semanticFatalError("Ya existe un parametro con el mismo nombre");
							}else{
								sp.addParametro(p);
								RESULT = new SecuenciaParametros(sp.getParametros());
							}
						:}
			| parametro:p {: RESULT = new SecuenciaParametros(p); :};

parametro ::= secuencia_IDs:sid DOS_PUNTOS tipo_primitivo:tp {: RESULT = new Parametro(sid,tp.getTipo()); :};

// Declaracion de funcion 
decl_funcion ::= FUNCTION ID:id decl_parametros:dparam DOS_PUNTOS tipo_primitivo:tp  PUNTO_Y_COMA 
					{:
					   if(!scopeManager.containsSymbol(id.getLexema())){
					   	   ScopeIF scope = scopeManager.getCurrentScope();
					   	   TypeFunction tF = new TypeFunction(scope,id.getLexema(),tp.getTipo());
					   	   SymbolFunction sF = new SymbolFunction(scope,id.getLexema(),tF);						   	   
					   	   scope.getSymbolTable().addSymbol(sF);	
					   	   scope.getTypeTable().addType(tF);
					   	   semanticErrorManager.semanticInfo("AGREGADO SIMBOLO " + id.getLexema() + " A LA TABLA DE SiMBOLOS");

				           ScopeIF nScope = scopeManager.openScope(id.getLexema());
				           SymbolTableIF nTabla =  nScope.getSymbolTable();
				           TypeTableIF nTTabla = nScope.getTypeTable();	
				           
				           System.out.println("Entrando en el ambito: " + nScope.getName());
           				   System.out.println("---------------------------------------------");
				           				           
				           for (Parametro p : dparam.getParametros()){
				           		List<String> ids = p.getSecuenciaIDs().getIDs();
				           		tF.addParametro(p);
				           		
				           		for (String s: ids){
									
									if(!(nTabla.containsSymbol(s))){
										SymbolParameter simboloParametro = new SymbolParameter(scope,s,p.getTipo());
										nTabla.addSymbol(s,simboloParametro);	
										tF.addId();									
										semanticErrorManager.semanticInfo("AGREGADO SiMBOLO " + s + " A LA TABLA DE SiMBOLOS");
									}else{
										semanticErrorManager.semanticFatalError("Parametro ya creado en el mismo ambito");
									}
								}	
				           }	
			           }else{
			           	   semanticErrorManager.semanticFatalError("Nombre de la funcion ya utilizado");
			           }						
					:}declaraciones bloque  PUNTO_Y_COMA{: 					
						
						System.out.println("Saliendo del ambito: " + scopeManager.getCurrentScope().getName());
           				System.out.println("---------------------------------------------");
						scopeManager.closeScope(); 
						RESULT = new DeclaracionFuncion();
						:} ;

// Llamada a funcion o procedimiento (se diferencia en el analisis semantico de la llamada)
llamada_subprograma ::= ID:id PARENT_ABRIR secuencia_parametros_llamada:spl PARENT_CERRAR 
						{:
							ScopeIF scope = scopeManager.getCurrentScope();
							if (!scopeManager.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
							}else{
								SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
								TypeIF tipo = simbolo.getType();
								if (!(tipo instanceof TypeFunction) && !(tipo instanceof TypeProcedure)){		
									semanticErrorManager.semanticFatalError(id.getLexema() + " no es un subprograma");									
								}else{									
									TypeProcedure funcion = (TypeProcedure) tipo;
									if(funcion.getNumIds()!=spl.getParametros().size()){	
										semanticErrorManager.semanticFatalError("Numero de parametros incorrecto");	
									}
									if(!funcion.compararParametros(spl.getParametros())){											
										semanticErrorManager.semanticFatalError("No coinciden los tipos");
									}else{										
									 	RESULT = new LlamadaSubprograma(id.getLexema());
									}									
								}
							}
						:}
		| ID:id PARENT_ABRIR PARENT_CERRAR
			{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
					TypeIF tipo = simbolo.getType();
					if (!(tipo instanceof TypeFunction) && !(tipo instanceof TypeProcedure)){	
						semanticErrorManager.semanticFatalError(id.getLexema() + " no es una funcion");									
					}else{
						TypeProcedure funcion = (TypeProcedure) tipo;
						if (!(funcion.getParametros().size()==0)){
							semanticErrorManager.semanticFatalError("Se esperaban parametros de entrada");
						}else{
							 RESULT = new LlamadaSubprograma();
						}
					}
				}
			:};

secuencia_parametros_llamada ::= secuencia_parametros_llamada:spl COMA exp:e 
						{:
							RESULT = new SecuenciaParametrosLlamada(spl.getParametros(), e);						
						:}
				 | exp:e {: RESULT = new SecuenciaParametrosLlamada(e); :};

// Expresiones
exp ::= LITERAL_ENTERO:e {:RESULT = new Expresion (scopeManager.searchType("INTEGER"), e.getLine(), e.getColumn());:}
	| ID:id {:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
					RESULT = new Expresion (simbolo.getType(),id.getLine(),id.getColumn());
				}
			:}	
	| ID:id CIRCUNFLEJO 
		{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{					
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());					
			
					if (!simbolo.getType().getName().equals("POINTER")){
						semanticErrorManager.semanticFatalError(id.getLexema() + " no es un puntero");
					}else{
						RESULT = new Expresion (simbolo.getType(),id.getLine(),id.getColumn());
					}
				}
		:}
	| ID:i1 PUNTO ID:i2 
		{:				
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(i1.getLexema())){
					semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
				}else{							
					SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
					TypeRecord registro = (TypeRecord)simbolo.getType();						
					if (!registro.contieneCampo(i2.getLexema())){
						semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
					}else{
						HashMap<String,CampoRegistro> campos = registro.getCampos();
						TypeIF tipoI2 = campos.get(i2.getLexema()).getTipo();	
						RESULT = new Expresion (tipoI2,i2.getLine(),i2.getColumn()); 
					}	
					
				}
		:}
	| ID:i1 PUNTO ID:i2 CIRCUNFLEJO 
		{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(i1.getLexema())){
					semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
				}else{	
					if (!scopeManager.containsSymbol(i2.getLexema())){
					semanticErrorManager.semanticFatalError(i2.getLexema() + " no definido");
					}else{	
						SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
						TypeRecord registro = (TypeRecord)simbolo.getType();						
						if (!registro.contieneCampo(i2.getLexema())){
							semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
						}else{
							HashMap<String,TypeIF> campos = registro.getCampos();
							TypeIF tipoI2 = campos.get(i2.getLexema());
							if (!tipoI2.getName().equals("POINTER")){
								semanticErrorManager.semanticFatalError(i2.getLexema() + " no es un puntero");
							}else{							
								RESULT = new Expresion (tipoI2,i2.getLine(),i2.getColumn()); 
							}
						}	
					}
				}
		:}
	| ARROBA ID:id 
			{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
				}else{
					SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
					RESULT = new Expresion (simbolo.getType(),id.getLine(),id.getColumn());
				}
			:}
	| ARROBA ID:i1 PUNTO ID:i2
		{:
				ScopeIF scope = scopeManager.getCurrentScope();
				if (!scopeManager.containsSymbol(i1.getLexema())){
					semanticErrorManager.semanticFatalError(i1.getLexema() + " no definido");
				}else{	
					if (!scopeManager.containsSymbol(i2.getLexema())){
					semanticErrorManager.semanticFatalError(i2.getLexema() + " no definido");
					}else{	
						SymbolIF simbolo = scopeManager.searchSymbol(i1.getLexema());
						TypeRecord registro = (TypeRecord)simbolo.getType();						
						if (!registro.contieneCampo(i2.getLexema())){
							semanticErrorManager.semanticFatalError(i1.getLexema() + " no contiene el campo" +i2.getLexema());
						}else{
							HashMap<String,TypeIF> campos = registro.getCampos();
							TypeIF tipoI2 = campos.get(i2.getLexema());
							RESULT = new Expresion (tipoI2,i2.getLine(),i2.getColumn()); 
						}	
					}
				}
		:} 
	| TRUE {:RESULT = new Expresion (scopeManager.searchType("BOOLEAN"));:}
	| FALSE {:RESULT = new Expresion (scopeManager.searchType("BOOLEAN"));:}
	| exp:e1 MENOS exp:e2 
		{:
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			if (!t1.getName().equals("INTEGER") || !t2.getName().equals("INTEGER")){
				semanticErrorManager.semanticFatalError("Tipos no compatibles con el operador '-'");
			}else{			
				RESULT = new Expresion (scopeManager.searchType("INTEGER"));
			}
		:}
	| exp:e1 OR exp:e2 
		 {:	
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			
			if (!t1.getName().equals("BOOLEAN") || !t2.getName().equals("BOOLEAN")){
				semanticErrorManager.semanticFatalError("Tipos no compatibles para la disyuncion");
			}else{			
				RESULT = new Expresion (scopeManager.searchType("BOOLEAN"));
			}
		:}	
	| exp:e1 MAYOR_QUE exp:e2 
		{:
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			
			if (!t1.getName().equals("INTEGER") || !t2.getName().equals("INTEGER")){
				semanticErrorManager.semanticFatalError("Tipos no compatibles con el operador >");
			}else{
				Expresion exp = new Expresion (scopeManager.searchType("BOOLEAN"));
				TemporalFactoryIF tf = CompilerContext.getTemporalFactory(scope);
				Temporal temp = (Temporal) tf.create();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				List cod1 = e1.getIntermediateCode();
				List cod2 = e2.getIntermediateCode();
				cb.addQuadruples (cod1);
				cb.addQuadruples (cod2);
				LabelFactoryIF lf = CompilerContext.getLabelFactory();					
				LabelIF VERDADERO = lf.create();
				LabelIF FIN = lf.create();
				cb.addQuadruple ("CMP", e1.getResultado(), e2.getResultado()); 
				cb.addQuadruple ("BZ", VERDADERO); 
				cb.addQuadruple ("ASN", temp, new Value(0));
				cb.addQuadruple ("BR", FIN);
				cb.addQuadruple ("LABEL", VERDADERO);
				cb.addQuadruple ("ASN", temp, new Value(1));
				cb.addQuadruple ("LABEL", FIN);
				List cod=cb.create ();
				exp.setIntermediateCode (cod); 
				
				RESULT = exp;
			}	
		:}
	| exp:e1 IGUAL exp:e2 
		{:
			TypeIF t1 = e1.getTipo();
			TypeIF t2 = e2.getTipo();
			
			if (t1.getName() != t2.getName()){
				semanticErrorManager.semanticFatalError("Tipos no compatibles");
			}else{
				RESULT = new Expresion (scopeManager.searchType("BOOLEAN"));					
			}	
		:}
	| PARENT_ABRIR exp:e PARENT_CERRAR 
		{:
			RESULT = e;
		:}
	| llamada_subprograma:ls 
	{: 		
		System.out.println("LLAMANDO AL SUBPROGRAMA " + ls.getNombre());
		RESULT = new Expresion(scopeManager.searchType(ls.getNombre())); 
	:};


// Bloque de sentencias
bloque ::= BEGIN secuencia_sentencias END {: RESULT = new Bloque(); :}
	| BEGIN END {: RESULT = new Bloque(); :};

secuencia_sentencias ::= secuencia_sentencias  sentencia {: RESULT = new SecuenciaSentencias(); :} 
			| sentencia {: RESULT = new SecuenciaSentencias(); :};

sentencia ::= sentencia_asignacion {: RESULT = new Sentencia(); :} 
		| sentencia_if {: RESULT = new Sentencia(); :}
		| sentencia_for {: RESULT = new Sentencia(); :} 
		| llamada_subprograma PUNTO_Y_COMA {: RESULT = new Sentencia(); :}
		| sentencia_write {: RESULT = new Sentencia(); :};

// Sentencia asignacion
sentencia_asignacion ::= sentencia_asignacion_izq:sai DOS_PUNTOS_IGUAL exp:e PUNTO_Y_COMA
						{:
							ScopeIF scope = scopeManager.getCurrentScope();
							
							if (!scopeManager.containsSymbol(sai.getId())){
								semanticErrorManager.semanticFatalError("Simbolo " + sai.getId() + " no definido");
							}else{
								SymbolIF simbolo = scopeManager.searchSymbol(sai.getId());
								TypeIF tipo = simbolo.getType();
								
								if (tipo instanceof TypeInteger){	
									if(!(e.getTipo() instanceof TypeInteger) && !(e.getTipo() instanceof TypeFunction)){ 
										semanticErrorManager.semanticFatalError("Tipos incompatibles. Integer no es compatible con " + e.getTipo().getName());
									}								
								}else if (tipo instanceof TypeBoolean && !(e.getTipo() instanceof TypeFunction)){	
									if(!(e.getTipo() instanceof TypeBoolean)){
										semanticErrorManager.semanticFatalError("Tipos incompatibles");
									}																										
								}else if (tipo instanceof TypeRecord){	
									TypeRecord tipoRegistro = (TypeRecord)tipo;
									TypeIF tipoCampo = tipoRegistro.tipoCampo(sai.getCampo());
									if (tipoCampo instanceof TypeInteger && (!(e.getTipo() instanceof TypeInteger) && !(e.getTipo() instanceof TypeFunction))){	
										semanticErrorManager.semanticFatalError("Tipos incompatibles");											
									}else if (tipoCampo instanceof TypeBoolean && (!(e.getTipo() instanceof TypeBoolean) && !(e.getTipo() instanceof TypeFunction))){
										semanticErrorManager.semanticFatalError("Tipos incompatibles");
									}																
								}else{	//PUNTERO	
									if(!(e.getTipo() instanceof TypeInteger) && !(e.getTipo() instanceof TypeFunction)){ 
										semanticErrorManager.semanticFatalError("Tipos incompatibles. Integer no es compatible con " + e.getTipo().getName());
									}
								}							
							}	
							RESULT = new SentenciaAsignacion(); 							
						
						:};

sentencia_asignacion_izq ::= ID:id {: RESULT = new SentenciaAsignacionIzq(id.getLexema()); :}
			| ID:id CIRCUNFLEJO {: RESULT = new SentenciaAsignacionIzq(id.getLexema()); :}			
			| ID:id PUNTO ID:campo {: RESULT = new SentenciaAsignacionIzq(id.getLexema(),campo.getLexema()); :}
			| ID:id PUNTO ID:campo CIRCUNFLEJO {: RESULT = new SentenciaAsignacionIzq(id.getLexema()); :};

// Sentencia de control de flujo condicional if-then-else
sentencia_if ::= IF PARENT_ABRIR exp:e PARENT_CERRAR THEN sentencias_then_else_for parte_else
				{:	
					if(!(e.getTipo() instanceof TypeBoolean)){
						semanticErrorManager.semanticFatalError("La expresion de la condicion debe ser de tipo Boolean");
					}
					RESULT = new SentenciaIF();					
				:};	

sentencias_then_else_for ::= bloque PUNTO_Y_COMA {: RESULT = new SentenciasThenElseFor(); :}
			| sentencia {: RESULT = new SentenciasThenElseFor(); :};

parte_else ::= ELSE sentencias_then_else_for {: RESULT = new ParteElse(); :}
		| ;

// Sentencia de control de flujo iterativo for (las sentencias dentro de un bucle for siguen las mismas normas que para el if)
sentencia_for ::= FOR PARENT_ABRIR ID:id DOS_PUNTOS_IGUAL exp:e1 TO exp:e2 PARENT_CERRAR DO sentencias_then_else_for:sent
					{:
						ScopeIF scope = scopeManager.getCurrentScope();
						if (!scopeManager.containsSymbol(id.getLexema())){
							semanticErrorManager.semanticFatalError(id.getLexema() + " no definido");
						}else{
							SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
							if (!simbolo.getType().getName().equals("INTEGER")){	
								semanticErrorManager.semanticFatalError(id.getLexema() + " debe ser INTEGER");	
							}else{
								TypeIF t1 = e1.getTipo();
								TypeIF t2 = e2.getTipo();
								
								if (!t1.getName().equals("INTEGER") || !t2.getName().equals("INTEGER")){
									semanticErrorManager.semanticFatalError("Las expresiones deben ser INTEGER");	
								}
								RESULT = new SentenciaFor();
							}								
						}					
					:};

// Sentencias write y writeln
sentencia_write ::= WRITE PARENT_ABRIR parametro_write PARENT_CERRAR PUNTO_Y_COMA {: RESULT = new SentenciaWrite(); :}
		| WRITELN PARENT_ABRIR PARENT_CERRAR PUNTO_Y_COMA {: RESULT = new SentenciaWrite(); :};

parametro_write ::= exp:e {: RESULT = new ParametroWrite(); :} 
		| LITERAL_CADENA {: RESULT = new ParametroWrite(); :}
		| ;
